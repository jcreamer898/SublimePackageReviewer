{
  "name": "jquery-mockjax",
  "version": "1.5.2",
  "main": [
    "jquery.mockjax.js"
  ],
  "gitHead": "1791e1abb4c507b3fe53eda990c7e71ba2f9c836",
  "readme": "# jQuery Mockjax: Ajax request mocking #\n[http://github.com/appendto/jquery-mockjax/](http://github.com/appendto/jquery-mockjax/)\n\njQuery Mockjax provides request/response mocking for ajax requests with\njQuery and provides all standard behaviors in the request/response flow.\n\nYou may report any issues you may find [https://github.com/appendto/jquery-mockjax/issues](in the github issue tracking).\n\n### jQuery Version Support ###\n\nThe current version of Mockjax has been tested with jQuery 1.3.2 through\n1.7.0 with QUnit unit tests, residing in /test.\n\n### Browsers Tested ###\nInternet Explorer 6-9, Firefox 3.6 and stable, Safari 5.x, Chrome stable, Opera 9.6-latest.\n\n### Release History ##\n[CHANGELOG](https://github.com/appendto/jquery-mockjax/blob/master/CHANGELOG.md)\n\n## License ##\nCopyright (c) 2012 appendTo LLC.\n\nDual licensed under the MIT or GPL licenses.\n\n[http://appendto.com/open-source-licenses](http://appendto.com/open-source-licenses)\n\n## Documentation ##\n\nMost backend developers are familiar with the concepts of [mocking\nobjects](http://en.wikipedia.org/wiki/Mock_object) or stubbing in\nmethods for unit testing. For those not familiar with mocking, it’s the\nsimulation of an interface or API for testing or integration development\npurposes. Mocking with front-end development though is still quite new.\n\nMuch of the development that [appendTo](http://appendto.com) does\nfocuses on front-end development tied to\n[RESTFUL](http://en.wikipedia.org/wiki/Representational_State_Transfer)\nweb services. **As such we’re able to spec out the service contract and\ndata format at the beginning of a project and develop the front-end\ninterface against mock data while the back end team builds the\nproduction services.**\n\nThe plugin was originally developed by appendTo back in\nMarch 2010 and the [team](http://twitter.com/appendto/team) has been\nusing it in all of its projects since.\n\n### API\n\nMockjax consists of two methods, one to set up mocks, one to remove them.\nYou'll find plenty of examples below. If you're looking for a specific option,\ncheckout this list:\n\n* `$.mockjax(options)`\n  * Sets up a mockjax handler.\n  * `options`: An object literal which defines the settings to use for the mocked request.\n      * `url`: A string or regular expression specifying the url of the request that the data should be mocked for. If the url is a string and contains any asterisks ( * ), they will be treated as a wildcard by translating to a regular expression. Any `*` will be replaced with `.+`. If you run into trouble with this shortcut, switch to using a full regular expression instead of a string and asterisk combination.\n      * `data`: In addition to the URL, match parameters.\n      * `type`: Specify what HTTP method to match, usually GET or POST. Case-insensitive, so `get` and `post` also work.\n      * `headers`: An object literal whose keys will be simulated as additional headers returned from the server for the request.\n      * `status`: An integer that specifies a valid server response code. This simulates a server response code.\n      * `statusText`: An string that specifies a valid server response code description. This simulates a server response code description.\n      * `responseTime`: An integer that specifies a simulated network and server latency (in milliseconds).\n      * `isTimeout`: A boolean value that determines whether or not the mock will force a timeout on the request.\n      * `contentType`: A string which specifies the content type for the response.\n      * `response`: `function(settings) {}`, A function that allows for the dynamic setting of responseText/responseXML upon each request.\n      * `responseText`: A string specifying the mocked text, or a mocked object literal, for the request.\n      * `responseXML`: A string specifying the mocked XML for the request.\n      * `proxy`: A string specifying a path to a file, from which the contents will be returned for the request.\n      * `lastModified`: A date string specifying the mocked last-modified time for the request. This is used by `$.ajax` to determine if the requested data is new since the last request.\n      * `etag`: A string specifying a unique identifier referencing a specific version of the requested data. This is used by `$.ajax` to determine if the requested data is new since the last request. (see [HTTP_ETag](http://en.wikipedia.org/wiki/HTTP_ETag))\n* `$.mockjaxClear()`\n  * Removes all mockjax handlers.\n* `$.mockjaxClear(id)`\n  * Remove a single mockjax handler.\n  * `id` is the string returned from `$.mockjax`.\n\n### Overview: Your First Mock\n\nOur first example will be for a simple REST service for a fortune app\nwith the REST endpoint being `/restful/fortune` which returns the\nfollowing JSON message:\n\n    {\n        \"status\": \"success\",\n        \"fortune\" : \"Are you a turtle?\"\n    }\n\nTo pull the fortune into our page, we’d use the following HTML & jQuery\ncode:\n\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>Fortune App</title>\n        <script src=\"http://code.jquery.com/jquery-1.7.0.min.js\"></script>\n      </head>\n    <body>\n      <div id=\"fortune\"></div>\n    </body>\n    </html>\n\n    $.getJSON('/restful/fortune', function(response) {\n      if ( response.status == 'success') {\n        $('#fortune').html( 'Your fortune is: ' + response.fortune );\n      } else {\n        $('#fortune').html( 'Things do not look good, no fortune was told' );\n      }\n    });\n\nAt this point if we were to run this code it would fail since the REST\nservice has yet to be implemented. This is where the benefit of the\nMockjax Plugin starts to pay off. The first step in using Mockjax is to\ninclude the plugin by just adding a regular script tag.\n\nOnce you have that included, you can start intercepting Ajax requests\nand mocking the responses. So let’s mock out the service by including\nthe following code:\n\n    $.mockjax({\n      url: '/restful/fortune',\n      responseTime: 750,\n      responseText: {\n        status: 'success',\n        fortune: 'Are you a turtle?'\n      }\n    });\n\n**Defining a JSON string inline requires a `JSON.stringify` method to be\navailable. For some browsers you may need to include\n[json2.js](http://json.org/json2.js), which is included in the `lib` folder**\n\n**If you plan on mocking xml responses, you may also have to include\n`jquery.xmldom.js`, which can also be found in the `lib` folder.**\n\nWhat Mockjax does at this point is replace the `$.ajax` method with a\nwrapper that transparently checks the URL being requested. If the URL\nmatches one defined by `$.mockjax()`, Mockjax intercepts the request\nand sets up a mock `XMLHttpRequest` object before executing the\n`jQuery.ajax` handler. Otherwise, the request is handed back to the\nnative `$.ajax` method for normal execution. One benefit in this\nimplementation detail is by simulating the `XMLHttpRequest` object, the\nplugin continues to make use of jQuery’s native ajax handling.\n\nAs you write code to mock responses, there’s great value in the fact that there are no\nmodifications required to production code. The mocks can be\ntransparently inserted. This provides easy integration into most\nframeworks by including the plugin and mock definitions through your\nbuild framework. It’s also possible to include it at run time by\nlistening for a flag query string flag and injecting the plugin and\ndefinitions.\n\n### Mockjax in Depth\n\nNow let’s look at the various approaches to defining mocks as offered by\nthe plugin. The sections below feature an extensive overview of the\nflexibility in Mockjax and creating responses.\n\n## Data Types Available for Mocking\n\njQuery is able to handle and parse `Text`, `HTML`, `JSON`, `JSONP`,\n`Script` and `XML` data formats and Mockjax is able to mock any of those\nformats. Two things to note, depending upon how you mock out `JSON` and\n`JSONP` you may need to include [json2.js](http://json.org/json2.js) for\nthe `JSON.stringify()` method. Additionally if you mock XML inline,\nyou’ll need to include the\n[`xmlDOM`](http://github.com/appendto/jquery-xmldom) plugin that\ntransforms a string of XML into a DOM object. If you use the proxy\napproach outlined below, there’s no need to include either the JSON or\nXMLDOM plugins.\n\n## Step 1. Define the URL\n\nThe first thing you need to do when mocking a request is define the URL\nend-point to intercept and mock. As with our example above this can be a\nsimple string:\n\n    $.mockjax({\n      url: '/url/to/rest-service'\n    });\n\nor contain a `*` as a wildcard:\n\n    $.mockjax({\n      // Matches /data/quote, /data/tweet etc.\n      url: '/data/*'\n    });\n\nor a full regular expression:\n\n    $.mockjax({\n      // Matches /data/quote, /data/tweet but not /data/quotes\n      url: /^\\/data\\/(quote|tweet)$/i\n    });\n\nYou can also match against the data option in addition to url:\n\n    $.mockjax({\n        url:  '/rest',\n        data: { action: \"foo\" },\n        responseText: { bar: \"hello world\" }\n    });\n\n    $.mockjax({\n        url:  '/rest',\n        data: { action: \"bar\" },\n        responseText: { bar: \"hello world 2\" }\n    });\n\nTo capture URL parameters, use a capturing regular expression for the URL and a `urlParams` array to indicate, ordinally, the names of the paramters that will be captured.\n\n```javascript\n$.mockjax({\n  // matches /author/1234/isbn/1234-5678-9012-0\n  url: /^\\/author\\/([\\d]+)\\/isbn\\/([\\d\\-]+)$/,\n  urlParams: ['authorID', 'isbnNumber'],\n  response: function (settings) {\n    var authorID = settings.urlParams.authorID;\n    var isbnNumber = settigns.urlParams.isbnNumber;\n    //etc.\n  }\n});\n```\n\n### Step 2. Define the Response\n\nThe second step is to define the type of response. The two main\nproperties you’ll be dealing with are either `responseText` or\n`responseXML`. These properties mirror the native `XMLHttpRequest`\nobject properties that are set during a live response. There are three\ndifferent patterns for specifying the responses: Inline, Proxy, and\nCallback.\n\n#### Inline Responses\n\nA simple text response would be:\n\n    $.mockjax({\n      url: '/restful/api',\n      responseText: 'A text response from the server'\n    });\n\nA simple XML response would be:\n\n    $.mockjax({\n      url: '/restful/api',\n      // Need to include the xmlDOM plugin to have this translated into a DOM\n      responseXML: '<document><quote>Hello world!</quote></document>'\n    });\n\nAs you can quickly see, if you have a significant amount of data being\nmocked this becomes unwieldy. So that brings us to the next pattern,\nproxying.\n\n#### Proxy\n\nIn this example below, the Mockjax plugin will intercept requests for\n`/restful/api` and redirect them to `/mocks/data.json`.\n\n    $.mockjax({\n      url: '/restful/api',\n      proxy: '/mocks/data.json'\n    });\n\n#### Callback\n\nIn the final response pattern, we can define a callback on the\n`response` property and have it set `responseText` or `responseXML` as\nneeded.\n\n    $.mockjax({\n      url: '/restful/api',\n      response: function() {\n        this.responseText = 'Hello world!';\n      }\n    });\n\n### Advanced Mocking Techniques\n\nAt this point we’ve looked at a series of basic mocking techniques with\nMockjax and will now unpack some of the additional functionality\ncontained in the plugin.\n\n#### Simulating Response Time and Latency\n\nSimulating network and server latency for a mock is as simple as adding\na `responseTime` property to your mock definition:\n\n    $.mockjax({\n      url: '/restful/api',\n      // Simulate a network latency of 750ms\n      responseTime: 750,\n      responseText: 'A text response from the server'\n    });\n\n#### Simulating HTTP Response Statuses\n\nIt’s also possible to simulate response statuses other than 200 (default\nfor Mockjax) by simply adding a `status` property.\n\n    $.mockjax({\n      url: '/restful/api',\n      // Server 500 error occurred\n      status: 500,\n      responseTime: 750,\n      responseText: 'A text response from the server'\n    });\n\n#### Setting the Content-Type\n\nYou can set the content type to associate with the mock response, in the\nexample below, we’re setting a json content type.\n\n    $.mockjax({\n      url: '/restful/api',\n      contentType: 'text/json',\n      responseText: {\n        hello: 'World!'\n      }\n    });\n\n#### Setting Additional HTTP Response Headers\n\nAdditional HTTP Response Headers may be provided by setting a key in the\nheaders object literal:\n\n    $.mockjax({\n      url: '/restful/api',\n      contentType: 'text/json',\n      responseText: {\n        hello: 'World!'\n      },\n      headers: {\n        etag: 'xyz123'\n      }\n    });\n\n#### Force Simulation of Server Timeouts\n\nBecause of the way Mockjax was implemented, it takes advantage of\njQuery’s internal timeout handling for requests. But if you’d like to\nforce a timeout for a request you can do so by setting the `isTimeout`\nproperty to true:\n\n    $.mockjax({\n      url: '/restful/api',\n      isTimeout: true\n    });\n\n#### Dynamically Generating Mock Definitions\n\nIn some situations, all of your REST calls are based upon a URL schema.\nMockjax has the ability for you to specify a callback function that is\nhanded the `$.ajax` request settings. The callback function may then\neither return false to allow the request to be handled natively, or\nreturn an object literal with relevant Mockjax parameters set. Below is\nan example that rewrites all Ajax requests to proxy to static mocks:\n\n    $.mockjax(function(settings) {\n      // settings.url == '/restful/<service>'\n      var service = settings.url.match(/\\/restful\\/(.*)$/);\n      if ( service ) {\n        return {\n          proxy: '/mocks/' + service[1] + '.json'\n        };\n      }\n      return;\n    });\n\n#### Dynamically Generating Mock Responses\n\nIt’s also possible to dynamically generate the response text upon each\nrequest by implementing a callback function on the `response` parameter:\n\n    $.mockjax({\n      url: '/restful/webservice',\n      dataType: 'json',\n      response: function(settings) {\n        this.responseText = { say: 'random ' + Math.random() };\n      }\n    });\n\n#### Data types\n\nThe example above mocks a `json` response. You can also mock `xml`:\n\n    $.mockjax({\n      url: '/some/xml',\n      dataType: 'xml',\n      responseXML: '<document><say>Hello world XML</say></document>'\n    });\n\nAnd `html`:\n\n    $.mockjax({\n      url: '/some/webservice',\n      dataType: 'html',\n      responseText: '<div>Hello there</div>'\n    });\n\n#### Globally Defining Mockjax Settings\n\nIt’s also possible to define the global defaults for all Mockjax\nrequests by overwriting the `$.mockjaxSettings` object. By default the\nsettings are as follows:\n\n    $.mockjaxSettings = {\n      status:        200,\n      statusText     'OK',\n      responseTime:  500,\n      isTimeout:     false,\n      contentType:   'text/plain',\n      response:      '',\n      responseText:  '',\n      responseXML:   '',\n      proxy:         '',\n      lastModified:  null,\n      etag:          ''\n    };\n\nTo overwrite a particular settings such as the default content-type, you\nwould do the following:\n\n    $.mockjaxSettings.contentType = 'text/json';\n\n#### Removing Mockjax Handlers\n\nRemove all mockjax handlers:\n\n    $.mockjaxClear();\n\n#### Remove Single Mockjax Handler\n\n    var id = $.mockjax({\n       ...\n    });\n    $.mockjaxClear(id);\n",
  "readmeFilename": "README.md",
  "_id": "jquery-mockjax@1.5.2",
  "description": "[http://github.com/appendto/jquery-mockjax/](http://github.com/appendto/jquery-mockjax/)",
  "repository": {
    "type": "git",
    "url": "git://github.com/appendto/jquery-mockjax"
  }
}